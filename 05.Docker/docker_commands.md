# Docker

- installation on ubuntu

```bash
> sudo apt-get update
> sudo apt-get install ca-certificates curl
> sudo install -m 0755 -d /etc/apt/keyrings
> sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
> sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
> echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
> sudo apt-get update
> sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

# add the current user to the docker group
> sudo usermod -aG docker $USER

# logoff from current user or restart the machine
> sudo reboot
```

- installation on windows

  - https://docs.docker.com/desktop/setup/install/windows-install/

- installation on macOS
  - https://docs.docker.com/desktop/setup/install/mac-install/

## common commands

```bash

# get the list of objects
> docker <object> ls

# get the details of selected object
> docker <object> inspect <object id or name>

# remove an object
> docker <object> rm <object id or name>

# remove unused objects
> docker <object> prune

```

## system

```bash

# get the docker client and server version
> docker version

# get all the metadata or information of docker
> docker system info

# remove all unused resources
> docker system prune --volumes

```

## images

```bash

# get the list of images present on your machine
> docker image ls

# pull image from docker registry (hub.docker.com)
# > docker image pull <image name>
> docker image pull httpd

# get details of selected image
# > docker image inspect <image name>
> docker image inspect httpd

```

## container

- package which contains the code to solve the real time performant horizontal scaling issue

```bash

# get the list of running containers
> docker container ls

# get the list of all (hidden, created, not running, exited) containers
> docker container ls -a

# create a container
# send a request and get the response
# > docker container create <docker image name/id>
> docker container create httpd

# start the container
> docker container start <container id or name>

# stop the container
> docker container stop <container id or name>

# remove a stopped container
> docker container rm <container id or name>

# remove a running container
> docker container rm --force <container id or name>
> docker container rm -f <container id or name>

# run a container in attached mode
# note: this command creates a new container first
# run = create + start
# note: this command starts the container in attached mode
> docker container run <image name or id>

# run a container in detached mode
> docker container run -d <image name or id>

# run a container in detached mode with a name
> docker container run -d --name <container name> <image name or id>

# run a container with interaction with the container enabled
> docker container run -d -i --name <container name> <image name or id>
> docker container run -id --name <container name> <image name or id>

# run a container with interaction and teletype terminal in detached mode
> docker container run -i -t -d --name <container name> <image name or id>
> docker container run -itd --name <container name> <image name or id>

# get the log generated by the container
> docker container logs <container id or name>

# get the id of all running containers
> docker container ls -aq

# delete all the containers
# note: please execute this command on your own risk
> docker container rm --force $(docker container ls -aq)

# execute a command inside a container
> docker container exec -it <container id or name> <command>

# get the terminal for a container
# alpine based images use sh while ubuntu/debian/redhat based images use bash
> docker container exec -it <container id or name> <sh or bash>

# get the details of selected container
> docker container inspect <container id or name>

# expose the port to the an external application outside the container
# port publishing
> docker container run -itd --name myhttpd -p <os port number>:<container port> httpd

# run a container with port publishing or port forwarding
> docker container run -itd --name myhttpd -p 12345:80 httpd

# run a container for temporary use (when the container stops, it gets removed automatically)
> docker container run -itd --rm --name httpd -p 9090:80 httpd

# run a container with exposing environment variable(s)
> docker container run -itd --name <container> -p <os port>:<container port> -e <var name>=<var value> <image name or id>
> docker container run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root mysql

```

### run a mysql container

```bash

# start container
> docker container run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root mysql

```

```sql

-- create database
create database mydb;

-- use the database
use mydb;

-- create a table
create table persons(id integer primary key auto_increment, firstName varchar(10), lastName varchar(10), email varchar(50));

-- insert some dummy data
insert into persons (firstName, lastName, email) values ('steve', 'jobs', 'steve@apple.com');
insert into persons (firstName, lastName, email) values ('steve', 'jobs', 'steve@apple.com');

-- get all persons
select * from persons;

```

### modes

- attached mode

  - default mode of container execution
  - the container gets attached to the input (keyboard) and output (console) devices
  - until the container is running, the console wont be returned to the user

- detached mode
  - works like background mode
  - the container does not capture the input and output devices
  - to run container in detached mode use -d parameter

## volumes

- helps the container to persist the data outside the container
- even if the container gets removed, the data still stays live
- helps container to share contents with another container

```bash

# get a list of volumes
> docker volume ls

# create a new volume
# docker creates a new directory under /var/lib/docker/volumes
> docker volume create <volume name>
> docker volume create mysql-volume

# get details of selected volume
> docker volume inspect <volume name>

# remove a volume
> docker volume rm <volume name>

# run a container with required volume attached
> docker container run -itd --name mysql -p 3306:3306 -v mysql-volume:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root mysql

```

## network

```bash

# get the list of networks created by docker
> docker network ls

# get details of a selected network
> docker network inspect <network name>

# create a new network
> docker network create <network name>
> docker network create mynetwork

# create a container in newly created network
> docker container run -itd --name container3 --network mynetwork busybox

# remove a selected network
> docker network rm mynetwork

```

## customizing image

```bash

# create a new image committing a container
> docker container commit <container id or name> <image name>

# build an image
# note: if tag is not supplied, by default `latest` will be used
> docker image build -t <image name>:<tag> <build context>
> docker image build -t myimage .

# build an image for different platform
> docker buildx build --platform linux/amd64,linux/arm64 -t <image name>:<tag> .

```

### Dockerfile commands

- rules

  - all commands must be written in uppercase
  - every command must follow the structure => <command> <parameter>

- use .dockerignore file to ignore the files/directories while building an image

- FROM
  - used to select a base image
  - every custom image must select a base image
  - these images will be fetched from image registry
    - by default the docker public image registry is used to download the images (docker hub)
  - website: httpd, nginx
  - node: node
  - python: python3
  - java: java
- COPY:
  - used to copy contents (files/directory) from local machine to image
  - syntax
    - COPY <local path> <image path>
- WORKDIR:
  - used select a working directory in image
  - if the directory does not exist in the image, it will be created
  - this directory can be referred using dot (.)
- ADD:
- ENV:
  - used to expose an environment variable
- EXPOSE:
  - used to expose or open a required port
- RUN:
  - used to execute a command while building the image
  - this is a one time execution (at the time of building image)
- CMD:
  - used to execute a command inside container, while running a container
  - for every container this command executes and starts the container
  - if this commands fails, the container stops
  - CMD must be the last command in the Dockerfile
-

### push the image to docker hub

- register a new account on hub.docker.com

```bash

# login to the dockerhub
> docker login -u <username>

# rename or tag the older image with the format
# <dockerhub account name>/<image name>:<tag>
> docker image tag mywebsite:v4 amitksunbeam/mywebsite:v4

# push the newly tagged image to dockerhub
> docker image push <image name>

```

## compose

```bash

# find the version
> docker compose version

# validate if the docker configuration is right
> docker compose config

# list all the services from docker-compose.yml file
> docker compose config --services

# build all the images for all the services
> docker compose build

# force build all the images for all the services
> docker compose build --no-cache

# push all the images to docker image registry
> docker compose push

# get the list of containers running for the services
> docker compose ps

# run container in detached mode for each service
> docker compose up -d

# for images to get built and run container in detached mode for each service
> docker compose up -d --build

# get the logs for all the services
> docker compose logs

# get the logs of a selected service
> docker compose logs <service name>

# restart the services
> docker compose restart

# remove all the containers
> docker compose down

# remove all the containers and images as well
> docker compose down --rmi all


```

## swarm

```bash

# check if the current node is part of any swarm
> docker system info | grep Swarm

# initialize the swarm (cluster)
> docker swarm init

# leave the swarm
> docker swarm leave

# leave the swarm forcefully
> docker swarm leave --force

# generate token command to add another node as worker
> docker swarm join-token worker

# generate token command to add another node as manager
> docker swarm join-token manager

```

## node

```bash

# get the list of nodes
> docker node ls

# get the details of selected node
> docker node inspect <node id>

# remove a node from swarm
> docker node rm <node id>

```

## services

```bash

# get the list of services
> docker service ls

# create a service
# > docker service create --name <service name> <image name>
> docker service create --name http httpd

# create a service with multiple containers
> docker service create --replicas <count> --name <service name> <image name>

# create a service with port number for the containers
> docker service create --replicas 3 --name httpd -p 9090:80 httpd

# get the list of containers created by a service
> docker service ps <service name>

# remove a service
> docker service rm <service name>

# scale a service
> docker service scale <service name>=<new count>

```
